byte order : BE

首先我想谈谈自己几点看法，这个脚本二进制设计格式很有很多，
我们可以看到有很多都限制/问题，对于一些其中都问题我会谈谈自己的看法。

首先我们可以看到这是一个多binary的架构，为什么不打包成一个呢，还要做这些Far call和Far jmp。
我的理解是，公司要为所有都PS平台做考虑，包括内存严重不足的PSP平台，很明显，15MB的内存占用对于PSP而言真的是太大了。

第二点，我能从指令设计角度推断出，源代码应该是类似NScripter那种类型的，所有的Routine都是基于label，
所以0x10 - 0x400（这个数值要看EntryPoint，一般是这么大）就是公开的jmp offset了，你也可以理解成导出表。每4BYTE就构成了一个Offset，
那么实际跳转都位置 = Offset + EntryPoint。
当然，那些Offset为0的位置就是未导出的。

统一BE还行，你PS3有足够的机能从LE到BE，为何要把这个负担交给PSP和PSV。何况PS4也是LE。

当然，你脚本里所有的jmp的实际地址都是offset + EntryPoint。

0x00 - 0x10 : Header
uint16_t EntryPoint
uint16_t SizeOfStruct // or JmpTableOffset
uint32_t Crc32
uint32_t Unk
uint32_t TalkCount

0x10 - 0x400(or depends on EntryPoint)
exported label offset table

(EntryPoint - 8) - EntryPoint : ???

EntryPoint - EOF : bytecode data

========================================

汉化思路?

裁剪文字，直到每一句都和日文文本一样长？
瞎讲八讲，你当翻译是中文就行了？

正确的方式是要修正几个jmp(jmp, if)对应的offset，最后修正exported label offset table里面导出的offset。
非常简单吧。

或者你做个编译器也行，反正原代码能还原成NScripter那种水平的脚本，那写个编译器就是分分钟的事情了。

剩下几个未知的数值怎么办呢。管他的，反正代码里也不会校验他们，
你填个0x114514也行。

========================================

如何调试?
2018了，我手里也没PSP，我只有一个PPSSPP模拟器。
别指望PPSSPP内置的调试器，我这个人很反感什么东西都写成GUI的。
你给我一个Console或者类Console都界面，像GDB或者Windbg就行了。

都要做调试了，那么这意味着你面对的群体就不是那群只会伸手和玩游戏的小白了。
很可惜，PPSSPP下个断点都让我感觉非常差。（这不意味着PPSSPP不行，只是调试功能确实不行）

那么我就还有两条路可以选，要么一如既往对着IDA怼，脑补其中的运行过程；或者就是自己基于PPSSPP写一个调试器。
如果我选择后者，这玩意很简单，估计两个小时就搞定了。可惜我这人非常懒，我认为我以后大概也不会碰PSP了，
我也不会为了这一次去写一个工具的，毕竟要动手是吧。说起来很简单，关掉JIT，自定义+分析cmd。
如果是基本的那几个功能，可能就10分钟的事，感觉类似于在hypervisor下调试器。
可我就是懒，不想写，并且确信这玩意写了也就我自己用。

那好，那就硬怼吧。如何怼这玩意我不想发表太多的评论，是吧，程序要运行，那么我就能得知其流程。
就在于是否恶心了。最后我选择的方案很简单，用windbg调试PPSSPP来间接实现调试PSP游戏，
没想到吧。

对于罚抄这个游戏，这么多年过去了，我从高中的时候搞这玩意的移植（导致高考失利）到现在也都6年了。
做这个坑既是因为自己对这个（垃圾）游戏有一种特殊的感情，也算是对我那不完美移植的一些弥补。
好，废话不多说了，留个文档方便后人参考。毕竟做汉化主要还是在于对文本质量的最求，而不是在程序上卡壳。

==============================================